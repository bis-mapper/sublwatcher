.RUNERR Error Subroutine
.REV: 11.1.0.08
*
*==============================================================================.
:INCLUDE,ecab$,B,1 .                                                            INCLUDE
@ . ****************************************************************************
@ .   SUBROUTINE - RUNERR Error Subroutine
@ .
@ .   SYNOPSIS   -
@ .    This error subroutine lets the run designer receive an 'error dump'
@ .    when a run fails, which contains the following information:
@ .
@ .    - Error message
@ .    - Failing run name, and its cabinet, drawer and report number
@ .    - Failing line number and function
@ .    - User-id, station and department of the run user
@ .    - Date and time of failure
@ .    - Section of the run control report which failed
@ .    - Variable definition and contents at time of failure
@ .    - First 25 lines of the output area, and -0 through -16
@ .
@ . ***This is a common Registered Error Routine (RER ) used by  BIS Script, BIS
@ .    Script calling Java Script, and by ICE.
@ .    It is used in the release database for BIS and ICE, and may be used by
@ .    user applications.
@ .
@ .   GLOBAL INPUT VARIABLES -
@ .   1. V190 can be used to send error dump to either a STATION or
@ .      user-id in v190. If v190 is not loaded, error dump is displayed
@ .      on user's terminal.
@ .      Some system runs like RS are released with v190 set to mapcoord,2
@ .
@ .      A. SENDING ERROR DUMP TO USER:
@ .         V190 should be loaded with user as described in @SNU format.
@ .         v190 cannot contain any spaces.
@ .         Usage: LDV,WP V190H18='mapcoord,2' or 'mapcoord,2,Z' .
@ .
@ .      B. SENDING ERROR DUMP TO STATION:
@ .         V190 should be loaded with a station number as to where the error
@ .         dump needs to be sent. If v190 is not loaded, error dump is
@ .         displayed on user's terminal .
@ .         Usage : @LDV V190I5=999 .
@ .
@ .      C. SPECIFYING THE NUMBER OF RENAME LEVELS TO DUMP
@ .         V192 should be loaded with the number of rename levels to dump.
@ .         Usage: LDV,WP V192I5=41 .
@ .
@ .      D. SPECIFYING THE NUMBER OF LINES TO DUMP IN EACH RENAME.
@ .         V193 should be loaded with the number of lines to dump in
@ .         each rename.
@ .         Usage : @LDV V193I6=25 .
@ .
@ .    2. V191 should be loaded with a text string which contains information
@ .     responsible for the run design.  Usually the name, location, phone,etc.
@ .     This will be displayed to the user so that the person responsbile can
@ .     be contacted.
@ .     Usage : @LDV V191S80='J.Doe -- Ext 7418' .
@ .
@ .   USAGE OF RER -
@ . *** This Register Error Routine was rewritten in BIS 11 to use @diag ***
@ . *** This RUN ERR was rewritten in BIS level 10 to use global variables ***
@ . *** After BIS 11, many global rer variables are no longer necessary ***
@ .   This error routine may be used in two ways:
@ .   1. As a debugging tool for the run designer.  The error dump will be
@ .      displayed on the run designer's terminal.  Pressing the PF1 key
@ .      will alternately display the error dump and the failing run control
@ .      report.
@ .   2. As a run error notification facility for production runs.  The error
@ .      dump is sent to a designated terminal.
@ .
@ .   Requirements for using this subroutine:
@ .
@ .   Call sequence from a BIS script at the beginning of run script:
@ .   @RSR,0,E,2  0100 . Optional, reserves the needed global variables for 2E0.
@ .   @RER,0,E,2  0001 . Required, register the RER.
@ .
@ .   COMMENTS -
@ .   1.The global variable requirement for RUNERR has increased by 25 variables
@ .     and 2000 bytes.
@ .
@ .   2.When RER is called at error in BIS run script,
@ .     i)  If global variables used in RER don't already exist then RER will
@ .         create them.
@ .     ii) If necessary, RER will clear all prior global variables to make
@ .         space so that RER can run successfully and generate the error dump.
@ .
@ .   3.This subroutine uses <*RER#....> variables.
@ .     Do not use these variables in your run.
@ .
@ .   4. In case of ICE
@ .      Variables <*sessionid> and <*lgc> are artifacts from ICE(ICESVCHND).
@ .      If both are present and call$ is at least 2 then we assume all other
@ .      global variables from ICESVCHND exist and the error report will be
@ .      added to ICE error log, regardless of the value of v190 and v191.
@ .
@ . ****************************************************************************
@.
@0100:.                                                          RSR setup
@     if <*calldate> eq '<*calldate>'  gto lin+1 ; gto lin+2 .
@     ldv,w <*calldate>a8=date11$,<*calltime>a8=time$,<*callmsec>i12=msec$ .
@     ldv <*RER#v487>i6  .
@     ldv <*RER#v488>i6  .
@     ldv <*RER#v489>s90 . to hold global and env vars longer than 10 chars
@     ldv <*RER#v490>i16 .
@     ldv <*RER#v491>i16 .
@     ldv <*RER#v492>h12 .
@     ldv <*RER#v493>i6  .
@     ldv <*RER#v494>i5  .
@     ldv <*RER#v495>h12 .
@     ldv <*RER#v496>h12 .
@     ldv <*RER#v497>a1 .
@     ldv <*RER#v499>s998 .
@     ldv <*RER#xrpt>i4 .
@     ldv <*RER#errdate>a8 .
@     ldv <*RER#errtime>a8 .
@     ldv <*RER#errno>i5=0 .
@     ldv <*RER#xcab>a4 .
@     ldv <*RER#xdw>a1 .
@     ldv <*RER#errrpt>i4=0 .
@     ldv <*RER#lln>i6=0 .
@     esr .
@0001:.                                                          RER entry
@     if <*RER#xrpt> eq '<*RER#xrpt>'  if glbstr$ le 2000 \
        clv,g  ldv <*RER#CLRGLB>a16=Y ; .
@     if <*RER#xrpt> eq '<*RER#xrpt>'  rsr 0100 ; .
@.
@.    Global variables (preset) ensure RER has variable space.
@.
@     chd 0  if ws$ gt 0  cls ; .
@     def,x,lin+2 <*RER#v488>,v192  if <*RER#v488> eq 9,(lin+1) ; gto lin+2 .
@     gto lin+2 .
@     ldv v192i5=41 .
@     def,x,lin+2 <*RER#v488>,v193  if <*RER#v488> eq 9,(lin+1) ; gto lin+2 .
@     gto lin+2 .
@     ldv v193i10=25 .
@     ldv,r <*RER#errno>=xerr$ .
@     ldv,w <*RER#errdate>=date11$,<*RER#errtime>=time$,<*RER#errrpt>=xrpt$,\
      <*RER#lln>=xline$ .
@     def,m <*RER#xcab>,xtype$  def,a <*RER#xdw>,xtype$ .
@     ldv,l <*RER#xcab> .
@     diag,0,f A,v192,v193 .
@     rnm,-0 -2  rnm,-2 -3 .
@     loc,-3,,0099 afm 2-30 'Variable Name' <col>i2,<start>i4 .
@     loc,-3,,0099 afm 2-30 'GLobal Variables' <col1>i2,<end>i4 .
@     dec,3 <end>  chg <lines>i4 <end> - <start>  inc,2 <start> .
@     call 0161 (<start>,<end>,<lines>) .
@     rnm,-0 -2  rnm,-2 -3 .
@     loc,-3,,0099 afm 2-30 'Enviromental Variables' <c>i2,<start>i4 .
@     loc,-3,,0099 afm 2-30 'Reserved Words' <col1>i2,<end>i4 .
@     art <start>+5 <start> .
@     art <end>-<start> <lines>i4 .
@     call 0161 (<start>,<end>,<lines>) .
@     loc,-3,,0099 afm 2-30 'Reserved Words' <c>i2,<start>i4 .
@     lzr,-3,0099 <end>,<chars>i3,<hdgs>i1 .
@     art <start>+4 <start> .
@     art <end>-<start>+1 <lines>i4 .
@     call 0161 (<start>,<end>,<lines>) .
@     rnm,-3 -2 .
@0099:.
@0072:.
@     brk,0,f .
@     if <*category> eq '<*category>'  gto lin+2 ; .
                          ICE Category ... <*category>
@     if <*service> eq  '<*service>'  gto lin+2 ; .
                          ICE Service  ... <*service>
--------------------------------------------------------------------------------
Variable space information
--------------------------------------------------------------------------------
@      . Calculate max # of variables
@     ldv,rw <*RER#v488>=maxvar$ .
@     dec,maxgvr$ <*RER#v488>  dec,maxevr$ <*RER#v488> .
@     ldv,rw <*RER#v488>=maxevr$ .
@     ldv,rw <*RER#v487>=envstr$ .
<*RER#v487> characters remaining for Environment Variables(<*RER#v488>(p))
@     ldv,rw <*RER#v488>=maxgvr$ .
@     ldv,rw <*RER#v487>=glbstr$ .
<*RER#v487> characters remaining for Global Variables(<*RER#v488>(p))
@     ldv,rw <*RER#v488>=maxvar$ .
@     ldv,rw <*RER#v487>=frestr$ .
@     dec,maxgvr$ <*RER#v488>  dec,maxevr$ <*RER#v488> .
<*RER#v487> characters remaining for Numbered or Named Variables(<*RER#v488>(p))
 Note: The minimum space needed for any variable is 19 bytes

@     brk .
@     add,-0,-2 .
@     rnm -1 .
@0040:.   End of Report generation
@.
@.    lsm,xerr$ <*RER#v499>  .                                 Error msg
@     def,m <*RER#v490>,xdrw$  def,a <*RER#v495>,xdrw$  ldv,w <*RER#xrpt>=xrpt$,\
      <*RER#lln>=xline$ .
@     ldv,p <*RER#v490>,<*RER#v495> .
@.    ***************  Dispatch report ************************************
@     def,i,lin+2 <*RER#v493>,<*SessionId> .
@     def,i,lin+1 <*RER#v493>,<*lgc>  gto 0058 .
@     ldv,p <*RER#v492>=0<*RER#v495><*RER#v490> .
@     dir,lin+1 <*RER#v492> ,,,,<*RER#v497> .
@.
@     def,x,0048 <*RER#v488>,v190  if <*RER#v488> eq 9,(0170) ; . do @SEN
@     if <*RER#v488> eq 2,3,6,7 . ; gto 0048 . check type, skip sen, snu
@     lcv,lin+1 t^ V190 ' ' ,<*RER#v488> .    Count spaces, if any
@     if  <*RER#v488>  gt 0,(0048) ; .      skip the snu
@     lcv,lin+1 b9 V190 ',' ,<*RER#v490> . Count commas, skip if > 2
@     if  <*RER#v490>  gt 2,(0048) ; .      skip the snu
@     ldv <*RER#v493>=4,<*RER#v496>=',,,,' .  Need max 4 commas
@     dec,<*RER#v490> <*RER#v493>  .          Minus what user supplied.
@     ldv,p <*RER#v489>=<*RER#v496>(1-<*RER#v493>)'0048' .
@     xqt '@snu,-1,'v190(p)<*RER#v489> .           XQT dynamic @snu
@     gto 0048 .
@0170:.
@     if v190 gt 0 & lt 100000 . ; gto 0048 .
@     if v190 eq stnum$,(0048) ; .
@     sen,-1,v190,,,0048 . ; gto 0048 .
@     if 0 ne orstan$,(END) ; gto 0053 .
@0048:.
@     if 0 ne orstan$,(END) ; ldv <*RER#v487>=2 .
@     if run$ eq '__LOGON'  cer xxx . Illegal cmd to allow GUI logon to revert
@0049:.
@     ldv,p <appdir>s256='%USERPROFILE%\sublwatcher' .
@     ldv,p <appexe>s256=<appdir>'\growlnotify.exe' .
@     ldv,p <galerticon>s256='/i:'<appdir>'\failed.png' .
@     ldv,p <gtitle>s256='/t: Schwoops!' .
@     ldv <msg>s80='Please review the error screen for futher information.' .
@     pc,r "<appexe>(p)"' '"<msg>"' '"<gtitle>"' '"<galerticon>" .
@.
@     dsp,-1,<*RER#v487>,2,,,,'Line'soe$'¬2          Roll'soe$'¬           '\
'                            <Run Error Dump>' .
@     ldv,w <*RER#v488>=dline$ .
@.
@     pc,bcw "del <appdir>\changes.txt" .                       Clean up file
@.
@     sys .                                                                     system
@     fdr,-0,,,lin+1 '' 'USERID','RUNNAME' ¬,user$,'sublwatcher'  gto 0140 .    currently running?
@     wat 1000 .                                                                pause for first time
@     RUN SUBLWATCHER .                                                         start file watcher utility
@     rel .
@.
@.     ***********  START LOGGING  *********************************************
@.     ***********  GET LOG CYCLE REPORT  **************************************
@0140:.
@     ldv <category>s20=<*category>,<service>s20=<*service>,\
         <SessionId>s20=<*SessionId>,<TransId>a11=<*TransId>,\
         <calldate>a8=<*CallDate>,<calltime>a8=<*CallTime>,\
         <callmsec>i12=<*CallMSec>,\
         <lgc>a4=<*lgc>,<lgd>a1=<*lgd>,<lgidx>a4=<*lgidx> .
@ . Bypass all logging if not 11f is missing new fields.
@     dvs,<lgc>,<lgd>,<lgidx>,0156 'StNum','opened','closed' <c3>a,<c4>h,<c5>h .
@     ldv,r <msgnbr>a6=<*msgnbr> .
@     ldv,w <timenow>A8=time$ .
@     rdl,<lgc>,<lgd>,<lgidx>,2 31-16,52-2 <logcycles>S20,<highvol>A2  .
@     ldv,p <logcycles>,<highvol> .
@     if <logcycles> eq 'Logging Off'  gto 0160 ; .
@     ldv <stnum>a5='@@@@@' .
@     if <highvol> eq 'Hi'  ldv,w <stnum>i5=stnum$ . ; .  HighVol check
@     ldv <logrpt>i4 .
@     ldv,pw <logdate>a8=date11$ .
@     drw,<lgc>,<lgd> ,,,,,,,,,<lastln>i8 .          Get the last line possible
@     fdr,<lgc>,<lgd>,<lgidx>,,,0141 '@' 'Log Date','StNum','Closed'  \
          '¬',<logdate>,<stnum>,'@@@@@'   ,<lln>i8 .
@     rln 'Log Rpt' <logrpt> .
@     if <highvol> ne 'Hi'  gto 0153 . allow overflow summary at end of log.
@     lzr,<lgc>,<lgd>,<logrpt> <lln>i8 .
@     if <lln> ge <lastln>  gto 0158 . ; gto 0153 .   index 11f overflowed
@.     ***********  SUMMARIZE PREVIOUS DAY  ************************************
@0141:.
@     if <logcycles> eq Daily,(0142),Weekly,(0143),Monthly,(0144) .  New Log Cycle
@     if <logcycles> eq 'High Volume',(0142) . ; .
@     gto 0160 .                                                Undefined cycle
@0142:.
@     chg <logrpt>   1 +<lgidx>  gto 0145 .                Start New Daily Cycle
@0143:.
@     dc dw=d11(<logdate>) <day>a10 .                   Start New Weekly Cycle
@     if <day> eq Sunday    chg <logrpt> 1 +<lgidx>  gto 0145 ; .
@     if <day> eq Monday    chg <logrpt> 2 +<lgidx>  gto 0145 ; .
@     if <day> eq Tuesday   chg <logrpt> 3 +<lgidx>  gto 0145 ; .
@     if <day> eq Wednesday  chg <logrpt> 4 +<lgidx>  gto 0145 ; .
@     if <day> eq Thursday  chg <logrpt> 5 +<lgidx>  gto 0145 ; .
@     if <day> eq Friday    chg <logrpt> 6 +<lgidx>  gto 0145 ; .
@     if <day> eq Saturday  chg <logrpt> 7 +<lgidx>  gto 0145 ; gto 0160 .
@0144:.
@     chg <logrpt> <logdate>(7-2) +<lgidx>  gto 0145 .   Start New Monthly Cycle
@0145:.
@     chg <lgskl>i4 <lgidx> -1 .     Use report before index for New Log Report
@.     for <highvol> use rpt per StNum, else Rpt# calc for cycle
@     if <highvol> ne 'Hi'  gto 0147 . ; .
@.      Monthly uses day+<lgidx>(=42 reports) for logs, avoid them for Hi volume
@     dup,<lgc>,<lgd>,<lgskl>  ldv,w <logrpt>=rpt$  if <logrpt> le 42  gto lin+0 .
@     ldv,w <logrpt>=rpt$  gto 0148 .
@0147:rep,<lgc>,<lgd>,<lgskl>,<lgc>,<lgd>,<logrpt> .  make fresh log
@0148:lok,<lgc>,<lgd>,<lgidx> . mark log in index
@     fnd,<lgc>,<lgd>,<lgidx>,,lin+1 '@' 'Log Date','StNum','Closed'  \
          '¬',<logdate>,<stnum>,'@@@@@'    ,<lln>i8  gto 0152 .
@     lzr,<lgc>,<lgd>,<lgidx> <lln> .
@     ln+,<lgc>,<lgd>,<lgidx>,<lln>,1  inc <lln> .
@0152:.
@     if <stnum> eq '@@@@@'  ldv <stnum>='' . ; .
@     wrl,<lgc>,<lgd>,<lgidx>,<lln> 'Log Rpt','Log Date','StNum','Opened'   \
        '¬',<logrpt>,<logdate>,<stnum>,<timenow>   .  mark idx with log open
@     sor,<lgc>,<lgd>,<lgidx> '' 'LogDate' tab$,1y11 .
@     cnt,-0     e 'logrpt','LogDate','Stnum' tab$,1,a,b .
@     rep,-0,<lgc>,<lgd>,<lgidx> .
@.     ***********  WRITE ENTRY IN LOG REPORT  *********************************
@.     After write, if log report full then close log.
@.     Not High Vol then send(SNU) error when last line is written
@.     Then skip write to log report when it is full.
@0153:ldv <lgusr>a11,<lgdpt>a4 .
@     ldv,wp <lgusr>=user$,<lgdpt>=depn$ .
@     ldv,w <cmsec>i12=msec$,<cdate>a8=date11$ .         Get current date, time
@     dc d11(<cdate>)-d11(<*CallDate>) <t1>i12 .    Past midnight - dif in days
@     chg <t2>i12 <t1> *60 *60 *24 *1000 .         Past midnight - dif in msecs
@     chg <active>i12 <cmsec> +<t2> -<callmsec> .          Active time in msecs
@     ldv <l1>s20=<SessionId>,<l5>s20=<category>,<l6>s20=<service> .
@     chg <lgskl>i4 <lgidx> -1 .      use result of rid idx-1 to form wrl line
@     rsl,<lgc>,<lgd>,<lgskl>  rnm,-0 -8 .
@     ln+,-8,,1,,tab$  ldv <ln>i9=stat1$ .             Form new line in a result
@     wrl,-8,<ln> \                                   To write a formatted line
 'UserId','Dept','SessionId','Date','Time','Active',\
 'Category','Service','MsgNbr','TransId' \
 '¬',<lgusr>,<lgdpt>,<l1>,<calldate>,<calltime>,<active>,\
  <l5>,<l6>,<msgnbr>,<TransId> .
@     rdl,-8,stat1$ 1-160 <logln>s .                       Read line written
@     lok,<lgc>,<lgd>,<logrpt> .                      and use ln+ to add to log
@     lzr,<lgc>,<lgd>,<logrpt> <lln>i8 .              get max lines per report
@     if <lln> ge <lastln>  gto lin+2 .
@     ln+,<lgc>,<lgd>,<logrpt>,,1,,<logln>  ldv,w <lln>i9=stat1$ .
@     ulk .
@     if <lln> ge <lastln>  gto 0158 . when max in log
@     gto 0160 .
@.
@0158:if <highvol> ne 'Hi',(0157) . ; . prevent overflow if high volume
@     lok,<lgc>,<lgd>,<lgidx> . For HiVol close log at max so nxt a new opens
@     fnd,<lgc>,<lgd>,<lgidx> '@' 'Log Date','StNum','Closed'  \
          '¬',<logdate>,<stnum>,'@@@@@'    ,<lln>i8 .
@     wrl,<lgc>,<lgd>,<lgidx>,<lln> 'Closed' \
        '¬',<timenow> .
@     ulk .  Close out current report so that next log begins a new report .
@     gto 0160 .
@.
@0156:. update log index column headers to apply missing fields
@     lzr,<lgc>,<lgd>,<lgidx>,0160 ,,<hdrs>i4 .
@     lok,<lgc>,<lgd>,<lgidx> .
@     wrl,<lgc>,<lgd>,<lgidx>,<hdrs> 15-25 *,'.=====.========.========.'  .
@     dec <hdrs>  .
@     wrl,<lgc>,<lgd>,<lgidx>,<hdrs> 15-25 *,'.Stnum.Opened  .Closed  .'  .
@     dec <hdrs>  .
@     wrl,<lgc>,<lgd>,<lgidx>,<hdrs> 15-25 *,'.     .        .        .'  .
@     ulk .
@     rsl,<lgc>,<lgd>,<lgidx> .
@     dvs,-0,0160 'StNum','opened','closed' <c3>a,<c4>h,<c5>h .
@     gto 0140 .   now log should work .
@.
@0157:. Logging report Maxed, use last line used to sum up missing entries
@     ldv <lgusr>h11='ENTRY COUNT',<l1>s20='EVENT LOG FILLED' .
@     ldv,w <cmsec>i12=msec$,<cdate>a8=date11$ .         Get current date, time
@     dc d11(<cdate>)-d11(<*CallDate>) <t1>i12 .    Past midnight - dif in days
@     chg <t2>i12 <t1> *60 *60 *24 *1000 .         Past midnight - dif in msecs
@     chg <active>i12 <cmsec> +<t2> -<callmsec> .          Active time in msecs
@     ldv <calldate>h8=date11$,<calltime>h8=time$ .
@     rdl,<lgc>,<lgd>,<logrpt>,<lastln> 'UserID','Active','TransID' \
       <inusr>h,<inact>i,<lgcount>i .
@     if <inusr> ne <lgusr>  ldv <lgcount>=1,<inact>=<active> . ;\
        inc <lgcount>  inc,<active> <inact>  gto 0159 ; .
@     ldv,p <msg>s80=\
'Notify ICE administration that access log report '<logrpt>' is full!' .
@     brk .
 <msg>
@     brk .
@     msg <msg> .
@     snu,-0,mapcoord,2,,,lin+1 .
@0159:.
@     ldv <active>=<inact> .
@     ldv <l5>s20=<l1>,<l6>s20=<l1>,<msgnbr>h6='' .
@     lok,<lgc>,<lgd>,<logrpt> .
@     wrl,<lgc>,<lgd>,<logrpt>,<lastln> \             To write a formatted line
 'UserId','Dept','SessionId','Date','Time','Active',\
 'Category','Service','MsgNbr','TransId' \
 '¬',<lgusr>,' ',<l1>,<calldate>,<calltime>,<active>,\
  <l5>,<l6>,'    #=',<lgcount> .
@     ulk .
@     gto 0160 .
@0160:esr .                                                        Exit Logging
@.     ***********  END LOGGING  ***********************************************
@.     **************************Routine to sort variables ********************
@0161:(<start>,<end>,<lines>) .
@     rnm,-0 -2 .
@     brk  rnm,-0 -3 .
@     lzr,-3,0099 ,,<hdgs>i1 .
@     lnd,-2,<start>,<lines>,1 .
@     lnp,-3,<hdgs>,1 .
@0162:loc,-3,2,lin+1 afmt$ 2-27 '                           ' <lnp>i4,<imp>i4 .
@     art <imp>-1 <cpl1>i3 .
@     if <imp> eq 0  gto lin+2 ; rdl,-3,<cpl1>,0099 2-22 <appp>s .
@     wrl,-3,<imp> 2-26  ,<appp>~!@#  .
@     if <imp> ne 0  gto 0162 .
@     sor,-3 'a' 2-26 ¬,1  rnm,-0 -3 .
@     ldv <spac>s26='                           ' .
@0163:loc,-3,2,lin+2 afmt$ 2-26 '~!@#' ,<vtno>i4 .
@     wrl,-3,<vtno> 2-26  ,<spac> .
@     if <vtno> ne 0  gto 0163 .
@     lnd,-3,2,<lines>,1 .
@     lzr,-3,0099 ,,<hdgs>i1 .
@     if <start> gt <hdgs>  dec <start> .
@     lnp,-2,<start>,1 .
@     rnm,-2 -0 .
@     return .
@.     **************************end of sorting variables  *********************
